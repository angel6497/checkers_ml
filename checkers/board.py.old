#!/usr/bin/env python3
# -*- coding: utf-8 -*-

#
# board.py
#


EMPTY = 0x0

BLACK = 0x1
WHITE = 0x2
PAWN  = 0x4
KING  = 0x8

BLACK_PAWN = BLACK | PAWN
BLACK_KING = BLACK | KING
WHITE_PAWN = WHITE | PAWN
WHITE_KING = WHITE | KING


_BOARD_STATE_INIT = [
    [ BLACK_PAWN, BLACK_PAWN, BLACK_PAWN, BLACK_PAWN ],
    [ BLACK_PAWN, BLACK_PAWN, BLACK_PAWN, BLACK_PAWN ],
    [ BLACK_PAWN, BLACK_PAWN, BLACK_PAWN, BLACK_PAWN ],

    [ EMPTY, EMPTY, EMPTY, EMPTY ],
    [ EMPTY, EMPTY, EMPTY, EMPTY ],

    [ WHITE_PAWN, WHITE_PAWN, WHITE_PAWN, WHITE_PAWN ],
    [ WHITE_PAWN, WHITE_PAWN, WHITE_PAWN, WHITE_PAWN ],
    [ WHITE_PAWN, WHITE_PAWN, WHITE_PAWN, WHITE_PAWN ],
]


_INNER_MOVES = {
    ( 0, 0 ) : [ ( 0, 1 ), ( 1, 1 ) ],
    ( 1, 0 ) : [ ( 1, 1 ), ( 2, 1 ) ],
    ( 2, 0 ) : [ ( 2, 1 ), ( 3, 1 ) ],
    ( 3, 0 ) : [ ( 3, 1 ) ],
    ( 0, 1 ) : [ ( 0, 0 ), ( 0, 2 ) ],
    ( 1, 1 ) : [ ( 0, 0 ), ( 1, 0 ), ( 1, 2 ), ( 0, 2 ) ],
    ( 2, 1 ) : [ ( 1, 0 ), ( 2, 0 ), ( 2, 2 ), ( 1, 2 ) ],
    ( 3, 1 ) : [ ( 2, 0 ), ( 3, 0 ), ( 3, 2 ), ( 2, 2 ) ],
    ( 0, 2 ) : [ ( 0, 1 ), ( 1, 1 ), ( 1, 3 ), ( 0, 3 ) ],
    ( 1, 2 ) : [ ( 1, 1 ), ( 2, 1 ), ( 2, 3 ), ( 1, 3 ) ],
    ( 2, 2 ) : [ ( 2, 1 ), ( 3, 1 ), ( 3, 3 ), ( 2, 3 ) ],
    ( 3, 2 ) : [ ( 3, 1 ), ( 3, 3 ) ],
    ( 0, 3 ) : [ ( 0, 2 ), ( 0, 4 ) ],
    ( 1, 3 ) : [ ( 0, 2 ), ( 1, 2 ), ( 1, 4 ), ( 0, 4 ) ],
    ( 2, 3 ) : [ ( 1, 2 ), ( 2, 2 ), ( 2, 4 ), ( 1, 4 ) ],
    ( 3, 3 ) : [ ( 2, 2 ), ( 3, 2 ), ( 3, 4 ), ( 2, 4 ) ],
    ( 0, 4 ) : [ ( 0, 3 ), ( 1, 3 ), ( 1, 5 ), ( 0, 5 ) ],
    ( 1, 4 ) : [ ( 1, 3 ), ( 2, 3 ), ( 2, 5 ), ( 1, 5 ) ],
    ( 2, 4 ) : [ ( 2, 3 ), ( 3, 3 ), ( 3, 5 ), ( 2, 5 ) ],
    ( 3, 4 ) : [ ( 3, 3 ), ( 3, 5 ) ],
    ( 0, 5 ) : [ ( 0, 4 ), ( 0, 6 ) ],
    ( 1, 5 ) : [ ( 0, 4 ), ( 1, 4 ), ( 1, 6 ), ( 0, 6 ) ],
    ( 2, 5 ) : [ ( 1, 4 ), ( 2, 4 ), ( 2, 6 ), ( 1, 6 ) ],
    ( 3, 5 ) : [ ( 2, 4 ), ( 3, 4 ), ( 3, 6 ), ( 2, 6 ) ],
    ( 0, 6 ) : [ ( 0, 5 ), ( 1, 5 ), ( 1, 7 ), ( 0, 7 ) ],
    ( 1, 6 ) : [ ( 1, 5 ), ( 2, 5 ), ( 2, 7 ), ( 1, 7 ) ],
    ( 2, 6 ) : [ ( 2, 5 ), ( 3, 5 ), ( 3, 7 ), ( 2, 7 ) ],
    ( 3, 6 ) : [ ( 3, 5 ), ( 3, 7 ) ],
    ( 0, 7 ) : [ ( 0, 6 ) ],
    ( 1, 7 ) : [ ( 0, 6 ), ( 1, 6 ) ],
    ( 2, 7 ) : [ ( 1, 6 ), ( 2, 6 ) ],
    ( 3, 7 ) : [ ( 2, 6 ), ( 3, 6 ) ]
}

_OUTER_MOVES = {
    ( 0, 0 ) : [ ( 1, 2 ) ],
    ( 1, 0 ) : [ ( 0, 2 ), ( 2, 2 ) ],
    ( 2, 0 ) : [ ( 1, 2 ), ( 3, 2 ) ],
    ( 3, 0 ) : [ ( 3, 2 ) ],
    ( 0, 1 ) : [ ( 1, 3 ) ],
    ( 1, 1 ) : [ ( 0, 3 ), ( 2, 3 ) ],
    ( 2, 1 ) : [ ( 1, 3 ), ( 3, 3 ) ],
    ( 3, 1 ) : [ ( 2, 3 ) ],
    ( 0, 2 ) : [ ( 1, 0 ), ( 1, 4 ) ],
    ( 1, 2 ) : [ ( 0, 0 ), ( 2, 0 ), ( 2, 4 ), ( 0, 4 ) ],
    ( 2, 2 ) : [ ( 1, 0 ), ( 3, 0 ), ( 3, 4 ), ( 1, 4 ) ],
    ( 3, 2 ) : [ ( 2, 0 ), ( 2, 4 ) ],
    ( 0, 3 ) : [ ( 1, 1 ), ( 1, 5 ) ],
    ( 1, 3 ) : [ ( 0, 1 ), ( 2, 1 ), ( 2, 5 ), ( 0, 5 ) ],
    ( 2, 3 ) : [ ( 1, 1 ), ( 3, 1 ), ( 3, 5 ), ( 1, 5 ) ],
    ( 3, 3 ) : [ ( 2, 1 ), ( 2, 5 ) ],
    ( 0, 4 ) : [ ( 2, 2 ), ( 2, 6 ) ],
    ( 1, 4 ) : [ ( 0, 2 ), ( 2, 2 ), ( 2, 6 ), ( 0, 6 ) ],
    ( 2, 4 ) : [ ( 1, 2 ), ( 3, 2 ), ( 3, 6 ), ( 1, 6 ) ],
    ( 3, 4 ) : [ ( 2, 2 ), ( 2, 6 ) ],
    ( 0, 5 ) : [ ( 1, 3 ), ( 1, 7 ) ],
    ( 1, 5 ) : [ ( 0, 3 ), ( 2, 3 ), ( 2, 7 ), ( 0, 7 ) ],
    ( 2, 5 ) : [ ( 1, 3 ), ( 3, 3 ), ( 3, 7 ), ( 1, 7 ) ],
    ( 3, 5 ) : [ ( 2, 3 ), ( 2, 7 ) ],
    ( 0, 6 ) : [ ( 1, 4 ) ],
    ( 1, 6 ) : [ ( 0, 4 ), ( 2, 4 ) ],
    ( 2, 6 ) : [ ( 1, 4 ), ( 3, 4 ) ],
    ( 3, 6 ) : [ ( 2, 4 ) ],
    ( 0, 7 ) : [ ( 1, 5 ) ],
    ( 1, 7 ) : [ ( 0, 5 ), ( 2, 5 ) ],
    ( 2, 7 ) : [ ( 1, 5 ), ( 3, 5 ) ],
    ( 3, 7 ) : [ ( 2, 5 ) ]
}



def get_inner_moves_by_coordinate(x, y):
    return _INNER_MOVES[( x, y )]


def get_outer_moves_by_coordinate(x, y):
    return _OUTER_MOVES[( x, y )]



class Board:
    '''
    TODO
    '''


    def __init__(self, state=_BOARD_STATE_INIT, features=()):
        if state:
            self.state = state
        if features:
            self.features = features

        self.history = []

    
    def __repr__(self):
        pieces = []
        for row in range(len(self.state)):
            for col in range(len(self.state[row])):
                piece = self.state[row][col]
                if piece == EMPTY:
                    pieces.append('0')
                elif piece == WHITE_KING:
                    pieces.append('-3')
                elif piece == WHITE_PAWN:
                    pieces.append('-1')
                elif piece == BLACK_PAWN:
                    pieces.append('1')
                elif piece == BLACK_KING:
                    pieces.append('3')

        return ' '.join(pieces)
                

    #def __repr__(self):
    #    return ('{} ' * 32).rstrip().format(
    #        self.state[0][0], self.state[0][1], self.state[0][2], self.state[0][3],
    #        self.state[1][0], self.state[1][1], self.state[1][2], self.state[1][3],
    #        self.state[2][0], self.state[2][1], self.state[2][2], self.state[2][3],
    #        self.state[3][0], self.state[3][1], self.state[3][2], self.state[3][3],
    #        self.state[4][0], self.state[4][1], self.state[4][2], self.state[4][3],
    #        self.state[5][0], self.state[5][1], self.state[5][2], self.state[5][3],
    #        self.state[6][0], self.state[6][1], self.state[6][2], self.state[6][3],
    #        self.state[7][0], self.state[7][1], self.state[7][2], self.state[7][3]
    #        )


    def get_legal_moves(self, color):
        moves = []

        for ( src, dst ) in self.__get_legal_moves(color):
            sx = src[0]
            sy = src[1]
            dx = dst[0]
            dy = dst[1]

            capture = None

            if abs(dy - sy) > 1:
                if dy < sy:
                    capture = ( ( dx, dy + 1 ), self.state[dy + 1][dx] )
                else:
                    capture = ( ( dx, dy - 1 ), self.state[dy - 1][dx] )

            promote = False

            if self.state[sy][sx] != BLACK_KING and self.state[sy][sx] != WHITE_KING:
                if dy == 0 or dy == 7:
                    promote = True

            m = Move(src, dst, capture, promote)

            moves.append(m)

        return moves


    def __get_legal_moves(self, color):
        moves = []

        jump = False

        for x in range(0, 4):
            for y in range(0, 8):
                state = self.state[y][x]

                if state & color:
                    for ( x_, y_ ) in self.__get_moves_by_coordinate(x, y):
                        if self.state[y_][x_] != EMPTY:
                            continue

                        src = ( x , y  )
                        dst = ( x_, y_ )

                        if not self.__legal_move_direction(state, src, dst):
                            continue

                        if abs(y_ - y) > 1:
                            if y_ < y:
                                if self.state[y_ + 1][x_] == EMPTY:
                                    continue
                                if self.state[y_ + 1][x_] & color:
                                    continue
                            else:
                                if self.state[y_ - 1][x_] == EMPTY:
                                    continue
                                if self.state[y_ - 1][x_] & color:
                                    continue

                            jump = True

                        moves.append(( src, dst ))

        if jump:
            moves = self.__del_inner_moves(moves)

        return moves


    def __legal_move_direction(self, state, src, dst):
        legal = True

        if dst[1] < src[1] and state == WHITE_PAWN:
            legal = False
        if dst[1] > src[1] and state == BLACK_PAWN:
            legal = False

        return legal


    def __get_moves_by_coordinate(self, x, y):
        moves = []

        moves += get_inner_moves_by_coordinate(x, y)
        moves += get_outer_moves_by_coordinate(x, y)

        return moves


    def __del_inner_moves(self, moves):
        return [ ( src, dst ) for ( src, dst ) in moves if abs(dst[1] - src[1]) > 1 ]


    def update(self, move):
        sx = move.src[0]
        sy = move.src[1]
        dx = move.dst[0]
        dy = move.dst[1]

        if self.state[sy][sx] == EMPTY:
            raise RuntimeError("Invalid move: Source tile empty")
        if self.state[dy][dx] != EMPTY:
            raise RuntimeError("Invalid move: Destination tile not empty")

        capture = move.capture

        if capture:
            self.state[capture[0][1]][capture[0][0]] = EMPTY

        self.state[dy][dx] = self.state[sy][sx]
        self.state[sy][sx] = EMPTY

        promote = move.promote

        if promote:
            self.state[dy][dx] &= ~PAWN
            self.state[dy][dx] |=  KING

        self.history.append(move)

        return


    def revert(self):
        move = self.history.pop()

        sx = move.src[0]
        sy = move.src[1]
        dx = move.dst[0]
        dy = move.dst[1]

        capture = move.capture

        if capture:
            self.state[capture[0][1]][capture[0][0]] = capture[1]

        self.state[sy][sx] = self.state[dy][dx]
        self.state[dy][dx] = EMPTY

        promote = move.promote

        if promote:
            self.state[sy][sx] &= ~KING
            self.state[sy][sx] |=  PAWN

        return


    def get_move_feature_values(self, move):
        values = []

        self.update(move)
        values = self._get_feature_values()
        self.revert()

        return values


    def get_feature_values(self):
        values = []

        for f in self.features:
            values.append(f.compute_value())

        return values



class Move:
    '''
    TODO
    '''

    def __init__(self, src, dst, capture=False, promote=False):
        self.src = src
        self.dst = dst
        self.capture = capture
        self.promote = promote

        return


    def __repr__(self):
        return 'Move(src={0}, dst={1}, capture={2}, promote={3})'.format(
            self.src, self.dst, self.capture, self.promote
            )
